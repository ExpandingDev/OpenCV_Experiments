#include <opencv2/core/core.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/videoio.hpp>
#include <opencv2/face.hpp>
#include <string>
#include <iostream>
#include <getopt.h>
#include <fstream>
#include <sys/stat.h>
#include <stdlib.h>
#include "FaceExtractor.h"
#include "helperFunctions.h"

#define PREPROCESS_MODE 0
#define TRAIN_MODE 1
#define RECOGNIZE_MODE 2

#define CAMERA_SOURCE 0
#define FILE_SOURCE 1

#define IMAGE_INPUT_DIR "input/"
#define TRAINING_DATA_DIR "data/"
#define MODEL_DIR "model/"

using namespace std;
using namespace cv;

///Using tutorials:
///https://www.learnopencv.com/eigenface-using-opencv-c-python/
///https://www.learnopencv.com/facial-landmark-detection/

unsigned short mode = 0;
unsigned short sourceType = 0;

FaceExtractor fe;

struct stat sb; // Used to make sure that a directory exists

const string usageMessage = "fident Usage:\n\
    \tfident [OPTIONS]\n\
    \n\
    OPTIONS may be one of:\n\
    \t-h\tDisplay this usage message\n\
    \t-p INPUT\tPREPARE mode         \n\
    \t-t\tTRAIN mode         \n\
    \t-r\tRECOGNIZE mode   \n\
    \t-c\tCAMERA input   \n\
    \t-f\tFILE input   \n\
    \t-b\tLBF Model Path, needed for PREPARE and RECOGNIZE mode. Default: lbfmodel.yaml\n\
    \t-l\tCascade Classifier Model Path, needed for PREPARE and RECOGNIZE mode.\n\
    \t-d HEIGHTxWIDTH\tSpecify the dimensions of training data.\n\
    \n\
    PREPARE mode reads the INPUT image and automatically crops and resizes it to create training data.\n\
    TRAIN mode reads training data stored in the \"data\" directory (should be generated by PREPARE mode) to train the model\n\
    RECOGNIZE mode reads the model configuration stored in the \"model\" directory to recognize and identify faces in the image source specified by the input arguments\
    \n\n\
    CAMERA input during RECOGNIZE mode will cause the recognizer to grab frames from the camera and recognize/identify faces in real time.\n\
    FILE input during RECOGNIZE mode will cause the recognizer to read the images from the specified DIRECTORY and perform identification on them.\n\
    \n\
    Defaults:\n\
    \tBy default, the program is in PREPARE mode. Additionally, if RECOGNIZE mode is set and -c or -f are not specified, then the program will default to CAMERA input mode.\n\
    During PREPARE and RECOGNIZE mode, the Cascade Classifier Model Path defaults to: /usr/share/opencv/haarcascades/haarcascade_frontalface_alt2.xml\n\
    The input dimensions for TRAIN mode and output dimensions for PREPROCESS mode are by default 150 by 150. This can be changed with the -d option.\n\
    Author: Tyler Sengia (tylersengia@gmail.com)\
    ";

void helpMessage() {
    cout << endl << usageMessage << endl;
}

///Extracts an aligned and cropped face from the specified image resized to the specified dimensions.
///Will return an empty Mat (Mat.data == NULL) if no face could be found.
Mat extractFace(string imagePath, Size outputDimensions) {
    cout << "Attempting to open " << imagePath << endl;
    //Try to open the file
    try {
        fstream inputStream(imagePath.c_str(), ios::in);
        cout << "Input file " << imagePath << " exists..." << endl;

        //Try to read in the image into a Matrix
        Mat inputFrame = imread(imagePath);
        if(inputFrame.data == NULL) {
            cerr << "Failed to read input image!" << endl;
            exit(-1);
        }

        //Extract the face(s) from the matrix
        vector<Mat> extracted = fe.extractFaces(inputFrame, outputDimensions);
        if(extracted.size() == 0) {
            cout << "WARNING: No face detected in " << imagePath << "!" << endl;
            return Mat(Size(1,1),CV_8U); // Return an empty matrix with a 1x1 size
        }
        else {
            if(extracted.size() > 1) {
                cout << "WARNING: More than one face detected in " << imagePath << "! Using the first face..." << endl;
            }

            return extracted[0];
        }

    }
    catch (std::ios_base::failure f) { // Input file does not exist
        cerr << "Input file " << imagePath << " could not be opened!" << endl;
        cerr << "Message: " << f.what() << endl;
        exit(-1);
    }
}

void preprocessMode(string lbfPath, string cascadePath, Size dimensions) {
    cout << "Preparing images from photos/ directory..." << endl;
    vector<string> ls = HelperFunctions::listFiles("photos/");
    bool done = false;

    //Remove from the list all files that are not images
    while(!done) {
        done = true;
        for(vector<string>::iterator i=ls.begin(); i != ls.end(); i++) {
            if(!(HelperFunctions::stringEndsWith(*i, ".png") || HelperFunctions::stringEndsWith(*i, ".jpg") || HelperFunctions::stringEndsWith(*i, ".gif") || HelperFunctions::stringEndsWith(*i, ".jpeg") || HelperFunctions::stringEndsWith(*i, ".exif") || HelperFunctions::stringEndsWith(*i, ".tif"))) {
                ls.erase(i);
                done = false;
                break;
            }
        }
    }

    //Check to make sure we still have files in the directory listing to use
    if(ls.size() == 0) {
        cerr << "Input directory does not contain any image files!" << endl;
        return;
    }

    //Get the output directory ready so we have somewhere to store the prepared images
    if(!HelperFunctions::prepareDirectory("prepared/")) {
        cerr << "Unable to create/open the prepared/ output directory!" << endl;
        return;
    }

    //Initialize the FaceExtractor
    fe = FaceExtractor(cascadePath, lbfPath);
    cout << "FaceExtractor loaded." << endl;

    // Process each image and output into output directory
    for(string imgPath : ls) {
        Mat prep = extractFace("photos/" + imgPath, dimensions);
        if(prep.rows == 1) { // No face found, so dont save anything
            continue;
        }
        string fileName = HelperFunctions::getBaseName(imgPath);
        if(imwrite("prepared/" + fileName, prep)) {
            cout << "Prepared image: " << fileName << endl;
        }
    }
    cout << "Done processing images!" << endl;
}

void trainMode() {

}

void recognizeMode() {

}

int main(int argc, char **argv)
{
    string inputFileDirectory = "photos/";
    string lbfModelPath = "lbfmodel.yaml";
    //string cascadeClassifierPath = "/usr/share/opencv/haarcascades/haarcascade_frontalface_alt2.xml";
    string cascadeClassifierPath = "/usr/share/opencv/lbpcascades/lbpcascade_frontalface.xml";
    string inputDimensions = "150x150";

    opterr = 0;
    mode = PREPROCESS_MODE;
    sourceType = CAMERA_SOURCE;
    int c;

    //Parse the arguments
    while((c = getopt(argc, argv, "hptrcf:d:l:b:")) != -1) {
        switch(c) {
            case 'h':
                helpMessage();
                exit(0);
                break;
            case 'p':
                mode = PREPROCESS_MODE;
                break;
            case 'd':
                inputDimensions = string(optarg);
                break;
            case 't':
                mode = TRAIN_MODE;
                break;
            case 'r':
                mode = RECOGNIZE_MODE;
                break;
            case 'c':
                sourceType = CAMERA_SOURCE;
                break;
            case 'f':
                sourceType = FILE_SOURCE;
                inputFileDirectory = string(optarg);
                break;
            case 'b':
                lbfModelPath = string(optarg);
                break;
            case 'l':
                cascadeClassifierPath = string(optarg);
                break;
            case '?':
                if(optopt == 'f') {
                    cerr << "Option -f requires an argument!" << endl;
                    helpMessage();
                    exit(1);
                }
                if(optopt == 'l') {
                    cerr << "Option -l requires an argument!" << endl;
                    helpMessage();
                    exit(1);
                }
                if(optopt == 'b') {
                    cerr << "Option -b requires an argument!" << endl;
                    helpMessage();
                    exit(1);
                }
                if(optopt == 'd') {
                    cerr << "Option -d requires an argument! Sepecify the height and width in pixels following the -d flag: -d HEIGHTxWIDTH" << endl;
                    helpMessage();
                    exit(1);
                }
                else if (isprint(optopt)) {
                    cerr << "Unknown option: " << optopt << endl;
                    helpMessage();
                    exit(1);
                }
                else {
                    cerr << "Unknown option character: " << optopt << endl;
                    exit(1);
                }
            default:
                abort();
        }
    }

    long h = 1;
    long w = 1;
    unsigned int s = inputDimensions.find("x");
    if(s == std::string::npos) {
        cerr << "The -d flag was specified but no 'x' character was found to split the string! Make sure you specify dimensions in the form of HEIGHTxWIDTH" << endl;
        exit(-1);
    }
    else {
        string hStr = inputDimensions.substr(0, s); // Grab the height
        string wStr = inputDimensions.substr(s+1); // Grab the width

        // Convert string representation of dimensions to longs
        h = strtol(hStr.c_str(),nullptr,10);
        w = strtol(hStr.c_str(),nullptr,10);

        //Make sure the user specified valid sizes
        if (h <= 0) {
            cerr << "Invalid HEIGHT specified for -d option!" << endl;
            exit(-1);
        }

        if(w <= 0) {
            cerr << "Invalid WIDTH specified for -d option!" << endl;
            exit(-1);
        }
    }

    Size dimensions(w,h);

    switch(mode) {
        case PREPROCESS_MODE:
            preprocessMode(lbfModelPath, cascadeClassifierPath, dimensions);
        break;
        case TRAIN_MODE:
            trainMode();
        break;
        case RECOGNIZE_MODE:
            recognizeMode();
        break;
        default:
            cerr << "Unknown MODE! This should never happen!!!" << endl;
            exit(-1);
        break;
    }

    return 0;
}
